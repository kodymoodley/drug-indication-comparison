.\" Automatically generated by Pod::Man 4.07 (Pod::Simple 3.32)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "UMLS::Similarity::jcn 3"
.TH UMLS::Similarity::jcn 3 "2015-06-23" "perl v5.24.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
UMLS::Similarity::jcn \- Perl module for computing the semantic 
relatednessof concepts in the Unified Medical Language System 
(UMLS) using the method described by Jiang and Conrath (1997).
.SH "CITATION"
.IX Header "CITATION"
.Vb 9
\& @inproceedings{JiangC97,
\&  Author = {Jiang, J. and Conrath, D.},
\&  Booktitle = {Proceedings on International Conference 
\&               on Research in Computational Linguistics},
\&  Pages = {pp. 19\-33},
\&  Title = {Semantic similarity based on corpus statistics 
\&           and lexical taxonomy},
\&  Year = {1997}
\& }
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use UMLS::Interface;
\&  use UMLS::Similarity::jcn;
\&
\&  my $umls = UMLS::Interface\->new(); 
\&  die "Unable to create UMLS::Interface object.\en" if(!$umls);
\&
\&  my $jcn = UMLS::Similarity::jcn\->new($umls);
\&  die "Unable to create measure object.\en" if(!$jcn);
\&
\&  my $cui1 = "C0005767";
\&  my $cui2 = "C0007634";
\&
\&  $ts1 = $umls\->getTermList($cui1);
\&  my $term1 = pop @{$ts1};
\&
\&  $ts2 = $umls\->getTermList($cui2);
\&  my $term2 = pop @{$ts2};
\&
\&  my $value = $jcn\->getRelatedness($cui1, $cui2);
\&
\&  print "The similarity between $cui1 ($term1) and $cui2 ($term2) is $value\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module computes the semantic similarity of two concepts in 
the \s-1UMLS\s0 according to a method described by Jiang and Conrath (1997). 
This measure is based on a combination of using edge counts in the \s-1UMLS 
\&\s0'is\-a' hierarchy and using the information content values of the concepts, 
as describedin the paper by Jiang and Conrath. Their measure, however, 
computes values that indicate the semantic distance between words (as 
opposed to their semantic similarity). In this implementation of the 
measure we invert the value so as to obtain a measure of semantic 
relatedness. Other issues that arise due to this inversion (such as 
handling of zero values in the denominator) have been taken care of 
as special cases.
.PP
The \s-1IC\s0 of a concept is defined as the negative log of the probabilty 
of the concept.
.PP
To use this measure, a propagation file containing the probability 
of a \s-1CUI\s0 for each of the CUIs from the source(s) specified in the 
configuration file. The format for this file is as follows:
.PP
.Vb 4
\& C0000039<>0.00003951
\& C0000052<>0.00003951
\& C0000084<>0.00003951
\& C0000096<>0.00003951
.Ve
.PP
A larger of example of this file can be found in the icpropagation file 
in the samples/ directory.
.PP
A propagation file can be created using the create\-icfrequency.pl and 
the create\-icpropagation.pl programs in the utils/ directory. The 
create\-icfrequency.pl program takes plain text and returns a list of 
CUIs that are mapped to the text and the CUIs frequency counts. This 
file can then be used by the create\-icpropagation.pl program to create 
a file containing a list of CUIs and their probability counts, or used 
directly by the umls\-similarity.pl program which will calculate the 
probability of a concept on the fly.
.SH "SELF SIMILARITY"
.IX Header "SELF SIMILARITY"
Since the Jiang and Conrath measure was initially calculated as 
a distance measure and turned into a similarity measure, we need 
to take care ofthe special cases in which the similarity of the 
two concepts results in zero but does not mean that the two 
concepts are not similar. Here is an explaination of how we did 
and why. This is taken from the discussion about this measure 
when it was being implemented in WordNet::Similarity. The 
actual message chain is located here:
.PP
<http://tech.groups.yahoo.com/group/wn\-similarity/message/8>
.PP
The Jiang and Conrath measure is calculated as follows:
.PP
.Vb 1
\& sim(c1, c2) = 1 / distance(c1, c2)
.Ve
.PP
where
.PP
.Vb 4
\& c1, c2 are the two concepts,
\& distance(c1, c2) = ic(c1) + ic(c2) \- (2 * ic(lcs(c1, c2)))
\& ic               = the information content of the concept.
\& lcs(c1, c2)      = the least common subsumer of c1 and c2.
.Ve
.PP
Now, we don't want distance to be 0 (=> similarity will become
undefined). The distance can be 0 in 2 cases...
.PP
(1) ic(c1) = ic(c2) = ic(lcs(c1, c2)) = 0
.PP
ic(lcs(c1, c2)) can be 0 if the lcs turns out to be the root
node (information content of the root node is zero). But since
c1 and c2 can never be the root node, ic(c1) and ic(c2) would be 0
only if the 2 concepts have a 0 frequency count, in which case, for
lack of data, we return a relatedness of 0 (similar to the lin case).
.PP
Note that the root node \s-1ACTUALLY\s0 has an information content of
zero. Technically, none of the other concepts can have an information
content value of zero. We assign concepts zero values, when
in reality their information content is undefined (due to zero
frequency counts). To see why look at the formula for information
content: ic(c) = \-log(freq(c)/freq(\s-1ROOT\s0)) {\fIlog\fR\|(0)? \fIlog\fR\|(1)?}
.PP
(2) The second case that distance turns out to be zero is when...
.PP
ic(c1) + ic(c2) = 2 * ic(lcs(c1, c2))
.PP
(which could have a more likely special case ic(c1) = ic(c2) =
ic(lcs(c1, c2)) if all three turn out to be the same concept.)
.PP
How should one handle this?
.PP
Intuitively this is the case of maximum relatedness (zero
distance). For jcn this relatedness would be infinity... But we
can't return infinity. And simply returning a 0 wouldn't work...
since here we have found a pair of concepts with maximum
relatedness, and returning a 0 would be like saying that they
aren't related at all.
.PP
So what could we return as the maximum relatedness value?
.PP
So the way I handled this was to try to find the smallest distance
greater than 0, so that sim would be a very high value, but not
infinity. To find this value of distance I consider the formula of
distance...
.PP
.Vb 1
\& distance = ic(c1) + ic(c2) \- (2 * ic(lcs(c1, c2)))
.Ve
.PP
we get distance = 0 if ic(c1) = ic(c2) = ic(lcs(c1, c2))
So consider the case that ic(c2) = ic(lcs(c1, c2), but ic(c1) is the
information content value just slightly more than that of ic(c2) (and
ic(lcs(c1, c2))). We want to find the value of distance corresponding
to such a case and this would be the next highest value of distance
after 0.
.PP
We could select ic(c2) and ic(lcs(c1, c2)) to represent a highly
specific concept or a highly general concept for this computation...
We'll decide which one to select later...
For now we want a formula to represent a value of
distance = \*(L"almost zero\*(R".
.PP
.Vb 1
\& ic(concept) = \-log(freq(concept)/freq(root))
.Ve
.PP
For ic(c1) to be just slightly more than ic(c2) (or ic(lcs(c1, c2))),
what if we just reduced freq(concept) in the above formula by 1. i.e.
.PP
.Vb 1
\& ic(c2) = ic(lcs(c1, c2)) = \-log(freq/rootFreq)
\&
\& ic(c1) = \-log((freq\-1)/rootFreq)
.Ve
.PP
Since frequency is counted in whole numbers, this is the closest
ic(c1) could be to ic(c2) (but not equal to it). With this formula we
would have
.PP
.Vb 2
\& distance = ic(c1) + ic(c2) \- (2 * ic(lcs(c1, c2)))
\&          = ic(c1) + ic(c2) \- (2 * ic(c2))
.Ve
.PP
\&... since ic(c2) = ic(lcs(c1, c2))
.PP
.Vb 2
\&          = ic(c1) \- ic(c2)
\&          = \-log((freq\-1)/rootFreq) + log(freq/rootFreq)
.Ve
.PP
Now comes the part where we want to decide whether to select a
highly specific concept or a highly general concept for ic2 and
ic3... I selected them to be the most general concepts for some non
mathematical reasons (tho' I think I had come up with some
mathematical ones)...
.PP
My reasons...
.PP
The most general concept is the root node... we always have the
frequency count of the root node (non zero)... (if the root node is
zero then there is something really wrong with the information
content computed). It would be very difficult to find the most
specific concept (tho' not impossible).
.PP
Somehow, mathematically, I had a feeling that the more general
ic(c1) and ic(c2) are, they would be closer to each other on the
log scale than if they were more specific concepts (I could be
mistaken and it could be the other way around... and I don't have a
proof right now to support what I'm saying)
.PP
anyway, taking the most general concepts (the root concept), we have
.PP
distance = \-log((rootFreq \- 1)/rootFreq) + log(rootFreq/rootFreq)
         = \-log((rootFreq \- 1)/rootFreq) + \fIlog\fR\|(1)
         = \-log((rootFreq \- 1)/rootFreq)
.PP
This is the distance corresponding to \*(L"almost zero\*(R"... And this is
what I put in the code for the 0 case (sim = infinity case).
.PP
With the hocus pocus above I have made an artificial bound on relatedness
to \*(L"almost infinity\*(R".
.SH "PROPAGATION"
.IX Header "PROPAGATION"
The Information Content (\s-1IC\s0) is  defined as the negative log 
of the probability of a concept. The probability of a concept, 
c, is determine by summing the probability of the concept 
ocurring in some text plus the probability its decendants 
occuring in some text:
.PP
For more information on how this is calculated please see 
the \s-1README\s0 file.
.SH "USAGE"
.IX Header "USAGE"
The semantic relatedness modules in this distribution are built as classes
that expose the following methods:
  \fInew()\fR
  \fIgetRelatedness()\fR
.SH "TYPICAL USAGE EXAMPLES"
.IX Header "TYPICAL USAGE EXAMPLES"
To create an object of the jcn measure, we would have the following
lines of code in the perl program.
.PP
.Vb 2
\&   use UMLS::Similarity::jcn;
\&   $measure = UMLS::Similarity::jcn\->new($interface);
.Ve
.PP
The reference of the initialized object is stored in the scalar
variable '$measure'. '$interface' contains an interface object that
should have been created earlier in the program (UMLS-Interface).
.PP
If the 'new' method is unable to create the object, '$measure' would 
be undefined.
.PP
To find the semantic relatedness of the concept 'blood' (C0005767) and
the concept 'cell' (C0007634) using the measure, we would write
the following piece of code:
.PP
.Vb 1
\&   $relatedness = $measure\->getRelatedness(\*(AqC0005767\*(Aq, \*(AqC0007634\*(Aq);
.Ve
.SH "CONFIGURATION OPTION"
.IX Header "CONFIGURATION OPTION"
The UMLS-Interface package takes a configuration file to determine 
which sources and relations to use when obtaining the path information.
.PP
The format of the configuration file is as follows:
.PP
\&\s-1SAB ::\s0 <include|exclude> <source1, source2, ... sourceN>
.PP
\&\s-1REL ::\s0 <include|exclude> <relation1, relation2, ... relationN>
.PP
For example, if we wanted to use the \s-1MSH\s0 vocabulary with only 
the \s-1RB/RN\s0 relations, the configuration file would be:
.PP
\&\s-1SAB ::\s0 include \s-1MSH
REL ::\s0 include \s-1RB, RN\s0
.PP
or
.PP
\&\s-1SAB ::\s0 include \s-1MSH
REL ::\s0 exclude \s-1PAR, CHD\s0
.PP
If you go to the configuration file directory, there will 
be example configuration files for the different runs that 
you have performed.
.PP
For more information about the configuration options please 
see the \s-1README.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), UMLS::Interface
.PP
\&\fIperl\fR\|(1), \fIUMLS::Similarity\fR\|(3)
.SH "CONTACT US"
.IX Header "CONTACT US"
.Vb 2
\&  If you have any trouble installing and using UMLS\-Similarity, 
\&  please contact us via the users mailing list :
\&
\&      umls\-similarity@yahoogroups.com
\&
\&  You can join this group by going to:
\&
\&      http://tech.groups.yahoo.com/group/umls\-similarity/
\&
\&  You may also contact us directly if you prefer :
\&
\&      Bridget T. McInnes: bthomson at cs.umn.edu 
\&
\&      Ted Pedersen : tpederse at d.umn.edu
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.Vb 4
\&  Bridget T McInnes <bthomson at cs.umn.edu>
\&  Siddharth Patwardhan <sidd at cs.utah.edu>
\&  Serguei Pakhomov <pakh0002 at umn.edu>
\&  Ted Pedersen <tpederse at d.umn.edu>
.Ve
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright 2004\-2011 by Bridget T McInnes, Siddharth Patwardhan, 
Serguei Pakhomov, Ying Liu and Ted Pedersen
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
